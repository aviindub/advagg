<?php

/**
 * @file
 * Advanced CSS/JS aggregation module.
 */

// Define default variables.
/**
 * Default space characters.
 */
define('ADVAGG_SPACE', '__');

/**
 * Default value to see if advanced CSS/JS aggregation is enabled.
 */
define('ADVAGG_ENABLED', TRUE);

/**
 * Default value to see if .gz files should be created as well.
 */
define('ADVAGG_GZIP', TRUE);

/**
 * Default value to see we use core's default grouping of CSS/JS files.
 */
define('ADVAGG_CORE_GROUPS', TRUE);

/**
 * Default value to see if we cache the full CSS/JS structure.
 */
define('ADVAGG_USE_FULL_CACHE', TRUE);

/**
 * Default value to see if we cache the file information.
 */
define('ADVAGG_USE_FILE_CACHE', TRUE);

/**
 * Default value of counter.
 */
define('ADVAGG_GLOBAL_COUNTER', 0);

/**
 * Send non blocking requests in order to generate aggregated files via HTTPRL.
 */
define('ADVAGG_USE_HTTPRL', TRUE);

// Core hook implementations.
/**
 * Implements hook_hook_info().
 */
function advagg_hook_info() {
  // List of hooks that can be inside of *.advagg.inc files.
  $advagg_hooks = array(
    'advagg_get_css_file_contents_alter',
    'advagg_get_css_aggregate_contents_alter',
    'advagg_get_js_file_contents_alter',
    'advagg_get_js_aggregate_contents_alter',
    'advagg_save_aggregate_alter',
    'advagg_build_aggregate_plans_alter',
  );
  $hooks = array();
  foreach ($advagg_hooks as $hook) {
    $hooks[$hook] = array('group' => 'advagg');
  }
  return $hooks;
}

/**
 * Implements hook_permission().
 */
function advagg_permission() {
  return array(
    'bypass advanced aggregation' => array(
      'title' => t('bypass advanced aggregation'),
      'description' => t('User can use URL query strings to bypass AdvAgg.'),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function advagg_menu() {
  list($css_path, $js_path) = advagg_get_root_files_dir();
  $file_path = drupal_get_path('module', 'advagg');

  $items = array();
  $items[$css_path[1] . '/%'] = array(
    'title' => "Generate css aggregate",
    'page callback' => 'advagg_missing_aggregate',
    'type' => MENU_CALLBACK,
    'access callback' => TRUE,
    'file path' => $file_path,
    'file' => 'advagg.missing.inc',
  );
  $items[$js_path[1] . '/%'] = array(
    'title' => "Generate js aggregate",
    'page callback' => 'advagg_missing_aggregate',
    'type' => MENU_CALLBACK,
    'access callback' => TRUE,
    'file path' => $file_path,
    'file' => 'advagg.missing.inc',
  );
  $items['admin/config/development/advagg'] = array(
    'title' => 'Advanced CSS/JS Aggregation',
    'description' => 'Configuration for Advanced CSS/JS Aggregation.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('advagg_admin_settings_form'),
    'type' => MENU_NORMAL_ITEM,
    'access arguments' => array('administer site configuration'),
    'file path' => $file_path,
    'file' => 'advagg.admin.inc',
    'weight' => -10,
  );
  $items['admin/config/development/advagg/config'] = array(
    'title' => 'Configuration',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  $items['admin/config/development/advagg/operations'] = array(
    'title' => 'Preform An Operation',
    'description' => 'Flush caches, set the bypass cookie, take drastic actions.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('advagg_admin_operations_form'),
    'type' => MENU_LOCAL_TASK,
    'access arguments' => array('administer site configuration'),
    'file path' => $file_path,
    'file' => 'advagg.admin.inc',
    'weight' => -9,
  );
  $items['admin/config/development/advagg/info'] = array(
    'title' => 'Information',
    'description' => 'More detailed information about advagg.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('advagg_admin_info_form'),
    'type' => MENU_LOCAL_TASK,
    'access arguments' => array('administer site configuration'),
    'file path' => $file_path,
    'file' => 'advagg.admin.inc',
    'weight' => -8,
  );
  return $items;
}

/**
 * Implements hook_cron().
 *
 * This should be ran about once a day.
 */
function advagg_cron() {
  $return = array();
  // Clear out all stale advagg aggregated files.
  module_load_include('inc', 'advagg', 'advagg.cache');
  $return[] = advagg_delete_stale_aggregates();

  // Remove aggregates that include missing files.
  $return[] = advagg_remove_missing_files_from_db();

  // Remove unused aggregates.
  $return[] = advagg_remove_old_unused_aggregates();
  return $return;
}

/**
 * Implements hook_flush_caches().
 *
 * @param $all_bins
 *   TRUE: Get all advagg cache bins
 */
function advagg_flush_caches($all_bins = FALSE) {
  // Get list of cache bins to clear.
  $bins = array();
  $bins[] = 'cache_advagg_aggregates';
  if ($all_bins) {
    $bins[] = 'cache_advagg_info';
  }
  return $bins;
}

/**
 * Implements hook_element_info_alter().
 *
 * @param $type
 *   Configuration array.
 */
function advagg_element_info_alter(&$type) {
  // Swap in our own aggregation callback.
  if (isset($type['styles']['#aggregate_callback'])) {
    $type['styles']['#aggregate_callback'] = '_advagg_aggregate_css';
  }
}

/**
 * Implements hook_theme_registry_alter().
 *
 * Replace template_process_html with _advagg_process_html
 *
 * @param $theme_registry
 *   The existing theme registry data structure.
 */
function advagg_theme_registry_alter(&$theme_registry) {
  if (!isset($theme_registry['html'])) {
    return;
  }

  // Replace core's process function with our own.
  $index = array_search('template_process_html', $theme_registry['html']['process functions']);
  if ($index !== FALSE) {
    $theme_registry['html']['process functions'][$index] = '_advagg_process_html';
  }
}

/**
 * Implements hook_admin_menu_cache_info().
 *
 * Add in a cache flush for advagg.
 */
function advagg_admin_menu_cache_info() {
  if (variable_get('advagg_enabled', ADVAGG_ENABLED)) {
    $caches['advagg'] = array(
      'title' => t('Adv CSS/JS Agg'),
      'callback' => 'advagg_admin_flush_cache',
    );
    return $caches;
  }
}

/**
 * Implements hook_admin_menu_output_alter().
 *
 * Add in a cache flush for advagg.
 */
function advagg_admin_menu_output_alter(&$content) {
  if (variable_get('advagg_enabled', ADVAGG_ENABLED)) {
    // Remove default core aggregation link.
    unset($content['icon']['icon']['flush-cache']['assets']);
  }
}

// Core CSS/JS override functions.
/**
 * Default callback to aggregate CSS files and inline content.
 *
 * Having the browser load fewer CSS files results in much faster page loads
 * than when it loads many small files. This function aggregates files within
 * the same group into a single file unless the site-wide setting to do so is
 * disabled (commonly the case during site development). To optimize download,
 * it also compresses the aggregate files by removing comments, whitespace, and
 * other unnecessary content. Additionally, this functions aggregates inline
 * content together, regardless of the site-wide aggregation setting.
 *
 * @param $css_groups
 *   An array of CSS groups as returned by drupal_group_css(). This function
 *   modifies the group's 'data' property for each group that is aggregated.
 *
 * @see drupal_aggregate_css()
 * @see drupal_group_css()
 * @see drupal_pre_render_styles()
 * @see system_element_info()
 */
function _advagg_aggregate_css(&$css_groups) {
  if (!advagg_enabled()) {
    return drupal_aggregate_css($css_groups);
  }
  $preprocess_css = advagg_file_aggregation_enabled('css');

  // Call hook_advagg_css_groups_alter().
  drupal_alter('advagg_css_groups', $css_groups, $preprocess_css);

  // For each group that needs aggregation, aggregate its items.
  $files_to_aggregate = array();
  // Allow for inline CSS to be between aggregated files.
  $gap_counter = 0;
  foreach ($css_groups as $key => $group) {
    switch ($group['type']) {
      // If a file group can be aggregated into a single file, do so, and set
      // the group's data property to the file path of the aggregate file.
      case 'file':
        if ($group['preprocess'] && $preprocess_css) {
          $files_to_aggregate[$gap_counter][] = $group;
        }
        break;
      // Aggregate all inline CSS content into the group's data property.
      case 'inline':
        $gap_counter++;
        $css_groups[$key]['data'] = '';
        foreach ($group['items'] as $item) {
          $css_groups[$key]['data'] .= drupal_load_stylesheet_content($item['data'], $item['preprocess']);
        }
        break;
    }
  }

  if (!empty($files_to_aggregate)) {
    $hooks_hash = advagg_get_current_hooks_hash();
    $css_hash = drupal_hash_base64(serialize($files_to_aggregate));
    $cache_id = 'advagg:css:' . $hooks_hash . ':' . $css_hash;
    if (variable_get('advagg_use_full_cache', ADVAGG_USE_FULL_CACHE) && $cache = cache_get($cache_id, 'cache_advagg_aggregates')) {
      $plans = $cache->data;
    }
    else {
      module_load_include('inc', 'advagg', 'advagg');
      $plans = advagg_build_aggregate_plans($files_to_aggregate, 'css');
      if (variable_get('advagg_use_full_cache', ADVAGG_USE_FULL_CACHE)) {
        cache_set($cache_id, $plans, 'cache_advagg_aggregates', CACHE_TEMPORARY);
      }
    }
    $css_groups = advagg_merge_plans($css_groups, $plans);
  }
}

/**
 * Returns a themed presentation of all JavaScript code for the current page.
 *
 * References to JavaScript files are placed in a certain order: first, all
 * 'core' files, then all 'module' and finally all 'theme' JavaScript files
 * are added to the page. Then, all settings are output, followed by 'inline'
 * JavaScript code. If running update.php, all preprocessing is disabled.
 *
 * @param $scope
 *   (optional) The scope for which the JavaScript rules should be returned.
 *   Defaults to 'header'.
 * @param $javascript
 *   (optional) An array with all JavaScript code. Defaults to the default
 *   JavaScript array for the given scope.
 *
 * @return
 *   All JavaScript code segments and includes for the scope as HTML tags.
 */
function advagg_get_js($scope, $javascript) {
  $output = '';

  // Filter out elements of the given scope.
  $items = array();
  foreach ($javascript as $key => $item) {
    if ($item['scope'] == $scope) {
      $items[$key] = $item;
    }
  }
  if (empty($items)) {
    return $output;
  }

  // The index counter is used to keep aggregated and non-aggregated files in
  // order by weight.
  $index = 1;
  $processed = array();
  $files = array();
  $preprocess_js = advagg_file_aggregation_enabled('js');

  // A dummy query-string is added to filenames, to gain control over
  // browser-caching. The string changes on every update or full cache
  // flush, forcing browsers to load a new copy of the files, as the
  // URL changed. Files that should not be cached (see drupal_add_js())
  // get REQUEST_TIME as query-string instead, to enforce reload on every
  // page request.
  $default_query_string = variable_get('css_js_query_string', '0');

  // For inline JavaScript to validate as XHTML, all JavaScript containing
  // XHTML needs to be wrapped in CDATA. To make that backwards compatible
  // with HTML 4, we need to comment out the CDATA-tag.
  $embed_prefix = "\n<!--//--><![CDATA[//><!--\n";
  $embed_suffix = "\n//--><!]]>\n";

  // Since JavaScript may look for arguments in the URL and act on them, some
  // third-party code might require the use of a different query string.
  $js_version_string = variable_get('drupal_js_version_query_string', 'v=');

  // Sort the JavaScript so that it appears in the correct order.
  uasort($items, 'drupal_sort_css_js');

  // Provide the page with information about the individual JavaScript files
  // used, information not otherwise available when aggregation is enabled.
  $setting['ajaxPageState']['js'] = array_fill_keys(array_keys($items), 1);
  unset($setting['ajaxPageState']['js']['settings']);
  drupal_add_js($setting, 'setting');

  // If we're outputting the header scope, then this might be the final time
  // that drupal_get_js() is running, so add the setting to this output as well
  // as to the drupal_add_js() cache. If $items['settings'] doesn't exist, it's
  // because drupal_get_js() was intentionally passed a $javascript argument
  // stripped off settings, potentially in order to override how settings get
  // output, so in this case, do not add the setting to this output.
  if ($scope == 'header' && isset($items['settings'])) {
    $items['settings']['data'][] = $setting;
  }

  // Loop through the JavaScript to construct the rendered output.
  $element = array(
    '#tag' => 'script',
    '#value' => '',
    '#attributes' => array(
      'type' => 'text/javascript',
    ),
  );
  foreach ($items as $item) {
    $query_string =  empty($item['version']) ? $default_query_string : $js_version_string . $item['version'];

    switch ($item['type']) {
      case 'setting':
        $js_element = $element;
        $js_element['#value_prefix'] = $embed_prefix;
        $js_element['#value'] = 'jQuery.extend(Drupal.settings, ' . drupal_json_encode(drupal_array_merge_deep_array($item['data'])) . ");";
        $js_element['#value_suffix'] = $embed_suffix;
        $output .= theme('html_tag', array('element' => $js_element));
        break;

      case 'inline':
        $js_element = $element;
        if ($item['defer']) {
          $js_element['#attributes']['defer'] = 'defer';
        }
        $js_element['#value_prefix'] = $embed_prefix;
        $js_element['#value'] = $item['data'];
        $js_element['#value_suffix'] = $embed_suffix;
        $processed[$index++] = theme('html_tag', array('element' => $js_element));
        break;

      case 'file':
        $js_element = $element;
        if (!$item['preprocess'] || !$preprocess_js) {
          if ($item['defer']) {
            $js_element['#attributes']['defer'] = 'defer';
          }
          $query_string_separator = (strpos($item['data'], '?') !== FALSE) ? '&' : '?';
          $js_element['#attributes']['src'] = file_create_url($item['data']) . $query_string_separator . ($item['cache'] ? $query_string : REQUEST_TIME);
          $processed[$index++] = theme('html_tag', array('element' => $js_element));
        }
        else {
          // By increasing the index for each aggregated file, we maintain
          // the relative ordering of JS by weight. We also set the key such
          // that groups are split by items sharing the same 'group' value and
          // 'every_page' flag. While this potentially results in more aggregate
          // files, it helps make each one more reusable across a site visit,
          // leading to better front-end performance of a website as a whole.
          // See drupal_add_js() for details.
          $key = 'aggregate_' . $item['group'] . '_' . $item['every_page'] . '_' . $index;
          $processed[$key] = '';
          $files[$key][$item['data']] = $item;
        }
        break;

      case 'external':
        $js_element = $element;
        // Preprocessing for external JavaScript files is ignored.
        if ($item['defer']) {
          $js_element['#attributes']['defer'] = 'defer';
        }
        $js_element['#attributes']['src'] = $item['data'];
        $processed[$index++] = theme('html_tag', array('element' => $js_element));
        break;
    }
  }

  // Aggregate any remaining JS files that haven't already been output.
  // This is the only hunk of code change from drupal_get_js().
  if ($preprocess_js && count($files) > 0) {
    // See if the full cache has this.
    $hooks_hash = advagg_get_current_hooks_hash();
    $js_hash = drupal_hash_base64(serialize($files));
    $cache_id = 'advagg:js:' . $hooks_hash . ':' . $js_hash;
    if (variable_get('advagg_use_full_cache', ADVAGG_USE_FULL_CACHE) && $cache = cache_get($cache_id, 'cache_advagg_aggregates')) {
      $processed = $cache->data;
    }
    else {
      module_load_include('inc', 'advagg', 'advagg');
      $new_structure = advagg_convert_js_structure($files);
      $plans = advagg_build_aggregate_plans($new_structure, 'js');
      foreach ($plans as $plan) {
        $preprocess_file = file_create_url($plan['data']);
        $js_element = $element;
        $js_element['#attributes']['src'] = $preprocess_file;
        $js_element['#browsers'] = $plan['browsers'];
        $processed[] = theme('html_tag', array('element' => $js_element));
      }
      // Remove Blanks.
      $processed = array_filter($processed);
      if (variable_get('advagg_use_full_cache', ADVAGG_USE_FULL_CACHE)) {
        cache_set($cache_id, $processed, 'cache_advagg_aggregates', CACHE_TEMPORARY);
      }
    }
  }

  // Keep the order of JS files consistent as some are preprocessed and others are not.
  // Make sure any inline or JS setting variables appear last after libraries have loaded.
  return implode('', $processed) . $output;
}

/**
 * Replacement for template_process_html().
 */
function _advagg_process_html(&$variables) {
  if (!advagg_enabled()) {
    return template_process_html($variables);
  }

  // Render page_top and page_bottom into top level variables.
  $variables['page_top'] = drupal_render($variables['page']['page_top']);
  $variables['page_bottom'] = drupal_render($variables['page']['page_bottom']);
  // Place the rendered HTML for the page body into a top level variable.
  $variables['page'] = $variables['page']['#children'];

  $variables['head'] = drupal_get_html_head();
  // CSS has nice hooks so we don't need to work around it.
  $variables['css'] = drupal_add_css();
  $variables['styles'] = drupal_get_css();

  // JS needs hacks.
  $javascript = advagg_get_full_js();
  if (!empty($javascript)) {
    $scopes = advagg_get_js_scopes($javascript);

    // Add JS to the header and footer of the page.
    foreach ($scopes as $scope => $use) {
      if (!$use) {
        continue;
      }
      $scripts = advagg_get_js($scope, $javascript);
      // Header scripts.
      if ($scope == 'header') {
        $variables['scripts'] = $scripts;
      }
      // Footer scripts
      elseif ($scope == 'footer') {
        $variables['page_bottom'] .= $scripts;
      }
      // Scripts in other places.
      elseif (isset($variables[$scope]) && is_string($variables[$scope])) {
        $variables[$scope] .= $scripts;
      }
    }
  }
}

/**
 * Get full JS array.
 *
 * Note that hook_js_alter(&$javascript) is called during this function call
 * to allow alterations of the JavaScript during its presentation. Calls to
 * drupal_add_js() from hook_js_alter() will not be added to the output
 * presentation. The correct way to add JavaScript during hook_js_alter()
 * is to add another element to the $javascript array, deriving from
 * drupal_js_defaults(). See locale_js_alter() for an example of this.
 *
 * @param $javascript
 *   (optional) An array with all JavaScript code. Defaults to the default
 *   JavaScript array for the given scope.
 * @param $skip_alter
 *   (optional) If set to TRUE, this function skips calling drupal_alter() on
 *   $javascript, useful when the calling function passes a $javascript array
 *   that has already been altered.
 *
 * @return
 *   The raw JavaScript array.
 *
 * @see drupal_add_js()
 * @see locale_js_alter()
 * @see drupal_js_defaults()
 */
function advagg_get_full_js($javascript = NULL, $skip_alter = FALSE) {
  if (!isset($javascript)) {
    $javascript = drupal_add_js();
  }
  if (empty($javascript)) {
    return FALSE;
  }

  // Allow modules to alter the JavaScript.
  if (!$skip_alter) {
    // Call hook_js_alter().
    drupal_alter('js', $javascript);
  }
  return $javascript;
}

/**
 * Get all javascript scopes set in the $javascript array.
 *
 * @param $javascript
 *   An array with all JavaScript code.
 *
 * @return
 *   Array of scopes that are currently being used.
 */
function advagg_get_js_scopes($javascript) {
  // Return if nothing given to us.
  if (empty($javascript) || !is_array($javascript)) {
    return FALSE;
  }

  // Filter out elements of the given scope.
  $scopes = array();
  foreach ($javascript as $key => $item) {
    // skip if the scope is not set.
    if (!is_array($item) || empty($item['scope'])) {
      continue;
    }
    if (!isset($scopes[$item['scope']])) {
      $scopes[$item['scope']] = TRUE;
    }
  }
  return $scopes;
}

/**
 * Apply the advagg changes to the $css_groups array.
 *
 * @param $css_groups
 *   An array of CSS groups as returned by drupal_group_css().
 * @param $plans
 *   An array of changes to do to the $css_groups array.
 * @return array
 *   New version of $css_groups.
 */
function advagg_merge_plans($css_groups, $plans) {
  foreach ($plans as $plan) {
    $plan_added = FALSE;
    foreach ($css_groups as $key => $group) {
      // Remove files from the old css array.
      $file_removed = FALSE;
      foreach ($css_groups[$key]['items'] as $k => $values) {
        if (   is_array($values)
            && array_key_exists('data', $values)
            && is_array($plan['items']['files'])
            && array_key_exists($values['data'], $plan['items']['files'])
              ) {
          unset($css_groups[$key]['items'][$k]);
          $file_removed = TRUE;
        }
      }

      // Replace first file of the old css array with one from advagg.
      if ($file_removed && !$plan_added) {
        $step = 0;
        do {
          $step++;
          $insert_key = '' . intval($key) . '.' . $step;
        } while (array_key_exists($insert_key, $css_groups));
        $css_groups[$insert_key] = $plan;
        $plan_added = TRUE;
      }
    }

    // Remove old css grouping if no files are left in it.
    foreach ($css_groups as $key => $group) {
      if (empty($css_groups[$key]['items'])) {
        unset($css_groups[$key]);
      }
    }
  }

  // Key sort and normalize the array before returning it.
  ksort($css_groups);
  return array_values($css_groups);
}

// Helper functions.
/**
 * Function used to see if aggregation is enabled.
 *
 * @return bool
 *   The value of the advagg_enabled variable.
 */
function advagg_enabled() {
  // Only run code below if advagg is enabled.
  if (variable_get('advagg_enabled', ADVAGG_ENABLED)) {
    // Do not use the cache if the disable cookie is set.
    $cookie_name = 'AdvAggDisabled';
    $key = drupal_hash_base64(drupal_get_private_key());
    if (!empty($_COOKIE[$cookie_name]) && $_COOKIE[$cookie_name] == $key) {
      $GLOBALS['conf']['advagg_enabled'] = FALSE;
      $GLOBALS['conf']['preprocess_css'] = FALSE;
      $GLOBALS['conf']['preprocess_js'] = FALSE;
    }
    // Disable advagg if requested.
    if (isset($_GET['advagg']) && $_GET['advagg'] == -1 && user_access('bypass advanced aggregation')) {
      $GLOBALS['conf']['advagg_enabled'] = FALSE;
      $GLOBALS['conf']['preprocess_css'] = FALSE;
      $GLOBALS['conf']['preprocess_js'] = FALSE;
    }
    // Enable core preprocessing if requested.
    if (isset($_GET['advagg-core']) && $_GET['advagg-core'] == 1 && user_access('bypass advanced aggregation')) {
      $GLOBALS['conf']['preprocess_css'] = TRUE;
      $GLOBALS['conf']['preprocess_js'] = TRUE;
    }
    // Enable debugging if requested.
    if (isset($_GET['advagg-debug']) && $_GET['advagg-debug'] == 1 && user_access('bypass advanced aggregation')) {
      $conf['advagg_debug'] = TRUE;
    }

  }

  return variable_get('advagg_enabled', ADVAGG_ENABLED);
}

/**
 * Get an array of all hooks and settings that affect aggregated files contents.
 *
 * @return
 *   array('variables' => array(...), 'hooks' => array(...))
 */
function advagg_current_hooks_hash_array() {
  // Put all enabled hooks and settings into a big array.
  $advagg_hash = array(
    'variables' => array(
      'advagg_gzip' => variable_get('advagg_gzip', ADVAGG_GZIP),
      'is_https' => $GLOBALS['is_https'],
      'advagg_global_counter' => advagg_get_global_counter(),
    ),
    'hooks' => advagg_hooks_implemented(FALSE),
  );

  // Allow other modules to add in their own settings and hooks.
  // Call hook_advagg_current_hooks_hash_array_alter().
  drupal_alter('advagg_current_hooks_hash_array', $advagg_hash);

  return $advagg_hash;
}

/**
 * Get the hash of all hooks & settings that affect aggregated files contents.
 *
 * @return string
 *   hash value.
 */
function advagg_get_current_hooks_hash() {
  $current_hash = &drupal_static(__FUNCTION__);

  if (!isset($current_hash)) {
    // Get all advagg hooks and variables in use.
    $current_hash_array = advagg_current_hooks_hash_array();

    // Generate the hash.
    $current_hash = drupal_hash_base64(serialize($current_hash_array));

    // Save into variables for verification purposes later on if not found.
    $settings = advagg_get_hooks_hash_settings($current_hash);
    if (empty($settings) && lock_acquire(__FUNCTION__, 5)) {
      // Save new hash into
      advagg_set_hooks_hash($current_hash, $current_hash_array);

      // Release lock
      lock_release(__FUNCTION__);
    }
  }

  return $current_hash;
}

/**
 * Store settings assoceated with hash.
 *
 * @return
 *   value from db_merge
 */
function advagg_set_hooks_hash($hash, $settings) {
  return db_merge('advagg_aggregates_hashes')
    ->key(array('hash' => $hash))
    ->fields(array('settings' => serialize($settings)))
    ->execute();
}

/**
 * Get back what hooks are implemented.
 *
 * @param $all
 *   If TRUE get all hooks related to css/js files.
 *   if FALSE get only the subset of hooks that alter the filename/contents.
 * @return array
 *   List of hooks and what modules have implemented them.
 */
function advagg_hooks_implemented($all = TRUE) {
  // Get hooks in use.
  $hooks = array(
    'advagg_get_css_file_contents_alter' => array(),
    'advagg_get_css_aggregate_contents_alter' => array(),
    'advagg_get_js_file_contents_alter' => array(),
    'advagg_get_js_aggregate_contents_alter' => array(),
    'advagg_save_aggregate_alter' => array(),
    'advagg_current_hooks_hash_array' => array(),
  );
  if ($all) {
    $hooks += array(
      'advagg_build_aggregate_plans_alter' => array(),
      'js_alter' => array(),
      'css_alter' => array(),
    );
  }
  // Call hook_advagg_hooks_implemented_alter().
  drupal_alter('advagg_hooks_implemented', $hooks, $all);

  foreach ($hooks as $hook => $values) {
    $hooks[$hook] = module_implements($hook);
  }
  return $hooks;
}

/**
 * Returns the hashes settings.
 *
 * @param $name
 *   The name of the variable to return.
 * @return
 *   The settings array or FALSE if not found.
 */
function advagg_get_hooks_hash_settings($hash) {
  $settings = db_select('advagg_aggregates_hashes', 'aah')
    ->fields('aah', array('settings'))
    ->condition('hash', $hash)
    ->execute()
    ->fetchField();

  return !empty($settings) ? unserialize($settings) : FALSE;
}

/**
 * Get the CSS & JS path for advagg.
 *
 * @return
 *   Example below:
 *   array(
 *     array(
 *       public://advagg_css,
 *       sites/default/files/advagg_css,
 *     ),
 *     array(
 *       public://advagg_js,
 *       sites/default/files/advagg_js,
 *     ),
 *   )
 */
function advagg_get_root_files_dir() {
  static $css_paths;
  static $js_paths;

  // Make sure directories are available and writable.
  if (empty($css_paths) || empty($js_paths)) {
    $css_paths[0] = 'public://advagg_css';
    $js_paths[0] = 'public://advagg_js';

    file_prepare_directory($css_paths[0], FILE_CREATE_DIRECTORY);
    file_prepare_directory($js_paths[0], FILE_CREATE_DIRECTORY);

    // Get the URI of the directory.
    $css_paths[1] = parse_url(file_create_url($css_paths[0]));
    $css_paths[1] = ltrim($css_paths[1]['path'], $GLOBALS['base_path']);
    $js_paths[1] = parse_url(file_create_url($js_paths[0]));
    $js_paths[1] = ltrim($js_paths[1]['path'], $GLOBALS['base_path']);
  }

  return array($css_paths, $js_paths);
}

/**
 * Given the type lets us know if advagg is enabled or disabled.
 *
 * @param $type
 *   css or js.
 *
 * @return
 *   TRUE or FALSE
 */
function advagg_file_aggregation_enabled($type) {
  if (defined('MAINTENANCE_MODE') && MAINTENANCE_MODE == 'update') {
    return FALSE;
  }
  if (isset($_GET['advagg']) && $_GET['advagg'] == 0 && user_access('bypass advanced aggregation')) {
    return FALSE;
  }
  if ($type == 'css') {
    return variable_get('preprocess_css', FALSE);
  }
  if ($type == 'js') {
    return variable_get('preprocess_js', FALSE);
  }
}

/**
 * Update the atime value in the advagg_aggregates_versions table.
 *
 * @param $aggregate_filenames_hash
 *   Hash of the groupings of files.
 * @param $aggregate_contents_hash
 *   Hash of the files contents.
 *
 * @return
 *   TRUE if a write to the DB was done.
 */
function advagg_update_atime($aggregate_filenames_hash, $aggregate_contents_hash) {
  $write_done = FALSE;
  // Set the cache id.
  $cache_id = 'advagg:db:' . $aggregate_filenames_hash . ADVAGG_SPACE . $aggregate_contents_hash;
  // Set db record.
  $record = array(
    'aggregate_filenames_hash' => $aggregate_filenames_hash,
    'aggregate_contents_hash' => $aggregate_contents_hash,
    'atime' => REQUEST_TIME,
  );

  // Use the cache to avoid hitting the database.
  if ($cache = cache_get($cache_id, 'cache_advagg_info')) {
    // See if the atime value needs to be updated;
    if (!empty($cache->data['atime']) && $cache->data['atime'] > REQUEST_TIME - (12*60*60)) {
      // If atime is less than 12 hours old, do nothing.
      return $write_done;
    }
  }

  // If lock is already acquired, return here.
  if (!lock_acquire($cache_id, 5)) {
    return $write_done;
  }

  // Update atime in DB.
  if (drupal_write_record('advagg_aggregates_versions', $record, array('aggregate_filenames_hash', 'aggregate_contents_hash'))) {
    $write_done = TRUE;
  }

  // Update the atime in the cache.
  // Get fresh copy of the cache now that we are in a lock.
  $cache = cache_get($cache_id, 'cache_advagg_info');
  // Set the atime.
  if (empty($cache->data)) {
    $cache = new stdClass();
  }
  $cache->data['atime'] = REQUEST_TIME;

  // Write to the cache.
  cache_set($cache_id, $cache->data, 'cache_advagg_info', CACHE_PERMANENT);

  // Release Lock.
  lock_release($cache_id);

  // Return if a write was done.
  return $write_done;
}

/**
 * Return the advagg_global_counter variable.
 *
 * @todo Allow this value to be kept in sync across a multisite.
 *
 * @return
 *   Int value.
 */
function advagg_get_global_counter() {
  $global_counter = variable_get('advagg_global_counter', ADVAGG_GLOBAL_COUNTER);

  return $global_counter;
}


/**
 * Cache clear callback for admin_menu/flush-cache/advagg.
 */
function advagg_admin_flush_cache() {
  module_load_include('inc', 'advagg', 'advagg.admin');
  advagg_admin_flush_cache_button();
}
